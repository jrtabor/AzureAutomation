workflow AutoShutdownFinal
{
    Param
    (
		
        [parameter(Mandatory=$false)]
        [object] $WebhookData,

        [parameter(Mandatory=$false)]
        [string] $InParam_SPOVMListName		
    )
   	
   #For Debug if required
    $VerbosePreference = "Continue"
   # $VerbosePreference = "SilentlyContinue"

   #Continue on error so the Runbook completes instead of suspending.
   #Esp. when access to subscription is denied or subscription not found
   #$ErrorActionPreference = "Continue"

   #If there is webhook data, assume runbook has been triggered via a webhook
    if ($WebhookData -ne $null) {

        # Collect properties of WebhookData
        $WebhookName    = $WebhookData.WebhookName
        $WebhookHeaders = $WebhookData.RequestHeader
        $WebhookBody    = $WebhookData.RequestBody

        # Collect individual headers. VMList information converted from JSON.
        $InputData = ConvertFrom-Json -InputObject $WebhookData.RequestBody
        $InParam_SPOId = $InputData.ItemId
        $InParam_SPOVMListName = $InputData.ListName
        
    } 
    #else non-webhook triggered, run across all items in the SharePoint Online List provided.
    else {
        #Check that a SharePoint list has been provided
        if ($InParam_SPOVMListName -eq $null) {
            throw "If not triggered by WebHook you need to specify a SharePoint Online VM List Name 'InParam_SPOVMListName'"
        }
        Write-Output "Non-Webhook triggered Runbook started."
        $InParam_SPOId = -1
    }
	
    #Retrive the RunAs Connection details
    $Conn = Get-AutomationConnection -Name 'AzureRunAsConnection'

    #Login with the RunAs Account
    Add-AzureRMAccount -ServicePrincipal -Tenant $Conn.TenantID `
        -ApplicationId $Conn.ApplicationID -CertificateThumbprint $Conn.CertificateThumbprint 
    
    #Retrieve the SharePointSDK Connection details
    $SPOConn = Get-AutomationConnection -Name 'SPOnline'

    #Retrieve Current Automation Account Name, needed to call child runbooks
    $AutomationAccountName = Get-AutomationVariable -Name "CurrentAutomationAccountName"
    
    #Retrieve Current Automation Account Resource Group, needed to call child runbooks
    $ResourceGroupName = Get-AutomationVariable -Name "CurrentResourceGroupName"
    
    #Retrieve KeyVault Name to get secure variables (Namely OMS Workspace Key)
    $KeyVaultName = Get-AutomationVariable -Name "KeyVaultName"

    #Get OMS Workspace details
    $OMSWorkspaceID = $null
    $OMSWorkspaceName = Get-AutomationVariable -Name "OMSWorkspaceName"
    $OMSWorkspaceID = Get-AutomationVariable -Name "OMSWorkspaceID"
    if ($OMSWorkspaceID -ne $null) {
        $OMSKey = (Get-AzureKeyVaultSecret -VaultName $KeyVaultName -Name "OMSWorkspaceKey-$($OMSWorkspaceName)").SecretValueText
        $LogType = "Runbook_AutoshutdownFinal"
    } else {
        $OMSKey = $null
        $LogType = $null
    }
    
    #Run all code as Inline script 
    #Note: $Using prefaced for all global variables
    InlineScript {

        #CheckShutdownScheduleEntry Function.  
        #Returns True if the time now, is in the specified TimeZone, falls inside the TimeRange provide
        #Returns False if the time now, is NOT in the specified TimeZone, falls inside the TimeRange provide
        function CheckShutdownSchedule ([string]$InParamTimeRange, [string]$InParamTimeZone)
	    {
	        # Initialising variables and set up from passed 
			$rangeStart, $rangeEnd, $parsedDay = $null
	        $currentTime = (Get-Date).ToUniversalTime()
			$strCurrentTimeZone = $InParamTimeZone
			
			$TZ = [System.TimeZoneInfo]::FindSystemTimeZoneById($strCurrentTimeZone)
		    $currentTime = [System.TimeZoneInfo]::ConvertTimeFromUtc($currentTime, $TZ)
            $midnight = $currentTime.AddDays(1).Date

            $DaysOfTheWeek = ((new-object system.globalization.datetimeformatinfo).DayNames)

	        try {
                if($InParamTimeRange.ToLower() -eq "always") {
                    $parsedDay = Get-Date "00:00"
                    $rangeStart = $parsedDay # Defaults to midnight
	                $rangeEnd = $parsedDay.AddHours(23).AddMinutes(59).AddSeconds(59) # End of the same day
                } else {
	                # Parse ranges if they contain '~'
	                if($InParamTimeRange -like "*~*") {
	                    $timeRangeComponents = $InParamTimeRange -split "~" | foreach {$_.Trim()}
	                    if($timeRangeComponents.Count -eq 2) {

	                        $rangeStart_s = $timeRangeComponents[0]
                            foreach ( $Day in $DaysOfTheWeek) {
                                if ($rangeStart_s -like "*$($Day)*") {
                                    $NextDate = Get-Date (0..6 | % {$currentTime.AddDays($_)} | ? {$_.DayOfWeek -eq $Day}) -Format "dd MMMM yyyy"
                                    $rangeStart_s = $rangeStart_s.ToUpper().Replace($Day.ToUpper(),$NextDate)
                                }   
                            }
                            #Write-Verbose "`trangeStart: $($rangeStart_s)"
                            $rangeStart = Get-Date $rangeStart_s
                            #Write-Verbose "`trangeStart: $(Get-Date $rangeStart -Format "dd/MM/yyyy HH:mm")"
                            
                            $rangeEnd_s = $timeRangeComponents[1]
                            foreach ( $Day in $DaysOfTheWeek) {
                                if ($rangeEnd_s -like "*$($Day)*") {
                                    $NextDate = Get-Date (0..6 | % {$currentTime.AddDays($_)} | ? {$_.DayOfWeek -eq $Day}) -Format "dd MMMM yyyy"
                                    $rangeEnd_s = $rangeEnd_s.ToUpper().Replace($Day.ToUpper(),$NextDate)
                                }   
                            }
                            #Write-Verbose "`trangeEnd: $($rangeEnd_s)"
                            $rangeEnd = Get-Date $rangeEnd_s
	                        #Write-Verbose "`trangeEnd: $(Get-Date $rangeEnd -Format "dd/MM/yyyy HH:mm")"
                            
	                        # Check for ranges crossing midnight
	                        if($rangeStart -gt $rangeEnd) {
                                # If current time is between the start of range and midnight tonight, interpret start time as earlier today and end time as tomorrow
                                if($currentTime -ge $rangeStart -and $currentTime -lt $midnight) {
                                    $rangeEnd = $rangeEnd.AddDays(1)
                                }
                                # Otherwise interpret start time as yesterday and end time as today   
                                else {
                                    $rangeStart = $rangeStart.AddDays(-1)
                                }
	                        }
	                    }
                        # Otherwise assume there is only record and don't need to split
	                    else {
	                        Write-Error "`tWARNING: Invalid time range format. Expects valid .Net DateTime-formatted start time and end time separated by '~'" 
	                    }
	                }
	                # Otherwise attempt to parse as a full day entry, e.g. 'Monday' or 'December 25' 
	                else {
	                    # If specified as day of week, check if today
	                    if($DaysOfTheWeek -contains $InParamTimeRange) {
	                        $NextDate = Get-Date (0..6 | % {$currentTime.AddDays($_)} | ? {$_.DayOfWeek -eq $InParamTimeRange}) -Format "dd MMMM yyyy"
                            $parsedDay = Get-Date "$($NextDate) 00:00"
                            #if($InParamTimeRange -eq (Get-Date).DayOfWeek) {
	                        #    $parsedDay = Get-Date "00:00"
	                        #}
                            # Otherwise skip as it isn't today
	                        #else {
	                            # Skip detected day of week that isn't today
	                        #}
	                    }
	                    # Otherwise attempt to parse as a date, e.g. 'December 25'
	                    else {
	                        $parsedDay = Get-Date $InParamTimeRange
	                    }
	    
	                    if($parsedDay -ne $null) {
	                        $rangeStart = $parsedDay # Defaults to midnight
	                        $rangeEnd = $parsedDay.AddHours(23).AddMinutes(59).AddSeconds(59) # End of the same day
	                    }                    
	                }
                }
                #Write-Verbose "Checking $($rangeStart) TO $($rangeEnd)"
	        }
	        catch {
	            # Record any errors and return false by default
	            Write-Error "`tWARNING: Exception encountered while parsing time range. Details: $($_.Exception.Message). Check the syntax of entry, e.g. '<StartTime> -> <EndTime>', or days/dates like 'Sunday' and 'December 25'"   
	            #Write-Verbose "TimeRange: $($InParamTimeRange)`tFalse"
                return $false
	        }
            
	        # Check if current time falls within range for shutdown
	        if($currentTime -ge $rangeStart -and $currentTime -le $rangeEnd) {
                #Write-Verbose "TimeRange: $($InParamTimeRange)`tTrue"
                return $true
	        }
	        else {
                #Write-Verbose "TimeRange: $($InParamTimeRange)`tFalse"
                return $false
	        }
	
	    } # End function CheckShutdownSchedule
		
        function AddToLog ([Object]$SPLogData) {

            if ($Using:OMSWorkspaceID -ne $null) {
                $LogData = ""
                foreach ($Key in $SPLogData.Keys) {
                    switch ($Key.Substring($Key.Length-2)) {
                        "_s" {$sep = '"';$trim=$Key.Length-2}
                        "_t" {$sep = '"';$trim=$Key.Length-2}
                        "_b" {$sep = '';$trim=$Key.Length-2}
                        "_d" {$sep = '';$trim=$Key.Length-2}
                        "_g" {$sep = '"';$trim=$Key.Length-2}
                        default {$sep = '"';$trim=$Key.Length}
                    }
                    $LogData = $LogData + '"' + $Key.Substring(0,$trim) + '":' + $sep + $SPLogData.Item($Key) + $sep + ','
                    #$Key
                }
                $TimeStamp = get-date (Get-Date).ToUniversalTime() 
                $LogData = $LogData + '"TimeStamp":"' + $timestamp + '"'
                Write-Verbose "LogData: $($LogData)"
$json = @"
{$($LogData)}
"@
                # Wrap in an array
                $json = "[$json]"
                
                $PostResult = Send-OMSAPIIngestionFile -customerId $Using:OMSWorkspaceID -sharedKey $Using:OMSKey -body $json -logType $Using:LogType -TimeStampField "TimeStamp"
                #$PostResult = Post-OMSData -omsWorkspaceId $Using:OMSWorkspaceID -omsSharedKey $Using:OMSKey -body ([System.Text.Encoding]::UTF8.GetBytes($json)) -logType $Using:LogType
                if ($PostResult -ne "Accepted") {
                    Write-Error "Error posting to OMS - $PostResult"
                }
            }

        }

        function GetTZ ([string]$TZ_string) {
            
            $r = [regex] "\[([^\[]*)\]"
            $match = $r.match($($TZ_string))
            
            # If there is a successful match for a Timezone ID
            if ($match.Success) {
                $TZId = $match.Groups[1].Value
                # Try and get a valid TimeZone entry for the matched TimeZone Id
                try {
                    
                    $TZ = [System.TimeZoneInfo]::FindSystemTimeZoneById($TZId)
                } 
                # Otherwise assume UTC
                catch {
                    
                    $TZ = [System.TimeZoneInfo]::FindSystemTimeZoneById("UTC")
                }
            } else {
                
                $TZ = [System.TimeZoneInfo]::FindSystemTimeZoneById("UTC")
            }
            return $TZ
        }

        function DirectStartStopVM (
            [Parameter(Mandatory=$true)]
            [ValidateSet('Start','Stop')]
            [string]$Action,

            [Parameter(Mandatory=$true)]
            [String]$ResourceGroupName,

            [Parameter(Mandatory=$true)]
            [String]$VMName
        ) {
            switch ($Action) {
                "Start" {
                    $ActionResult = Start-AzureRmVM -Name $target.VMName -ResourceGroupName $target.ResourceGroup 
                    $ActionResult
                    $VMStatus = Get-AzureRmVM -Name $target.VMName -ResourceGroupName $target.ResourceGroup -Status
                    $VMStatus
                

#Statuses[0]                : 
#  Code                     : ProvisioningState/succeeded
#  Level                    : Info
#  DisplayStatus            : Provisioning succeeded
#  Time                     : 26/07/2017 3:06:57 AM
#Statuses[1]                : 
#  Code                     : PowerState/running
#  Level                    : Info
#  DisplayStatus            : VM running
                }
                "Stop" {}
            }

        }

        # Set Action Constants
        $EmtpyAction = 0
        $TargetGood = 1
        $StopVM = 2
        $StartVM = 4
        $MultiVMs = 8

        #Set the SharePoint Online List Names from global variables
        $SPOVMListName = $Using:InParam_SPOVMListName
        #$SPOVMListName = "AzureVMSchedule"

        $SPLogData = @{
            Trigger_s = ""
            VMName_s = ""
            SubscriptionGUID_g = ""
            ResourceGroup_s = ""
            TargetState_s = ""
            ItemID_d = ""
            LocalTime_t = ""
            Action_s = ""
        }

        # Get a list of all Subscriptions that the current account has access to
        # This will be used to filter out records that account does not have access to
        $AvailableSubs = @()
        $AvailableSubs = Get-AzureRmSubscription -WarningAction SilentlyContinue 
        Write-Output "Available Sub Count: $($AvailableSubs.Count)"
        Write-Output "Available Sub IDs: $($AvailableSubs.Id)"

        $ResizeVMs = @()
        
        #If there is no WebHook Data then get all SPO records
        if ($Using:InParam_SPOId -eq -1) {
            Write-Output "Getting all SharePoint records"
            $SPOVMs = @()
            $SPOVMs = Get-SPListItem -SPConnection $Using:SPOConn -ListName $SPOVMListName
            
            $VMs = Get-AzureRmVM
            
            $UpdReq = $false
            foreach ($VM in $VMs) {
                $SPORec = $null
                $SPORec = $SPOVMs | Where-Object {($_.Title -eq $($VM.Name)) -and ($_.ResourceGroup -eq $($VM.ResourceGroupName)) -and ($_.SubscriptionGUID -in $AvailableSubs.Id)}
                if ($SPORec -eq $null) {
                    Write-Output "Adding $($VM.Name)"
                    $SPData = @{
                        Title = $VM.Name
                        SubscriptionGUID = $((Get-AzureRmResource -ResourceId $VM.Id).SubscriptionId)
                        ResourceGroup = $VM.ResourceGroupName
                        TimeZone = "(UTC+10:00) Canberra, Melbourne, Sydney [AUS Eastern Standard Time]"
                        VMSize = $($VM.HardwareProfile.VmSize)
                        ShutdownTimeRange = "Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday 12AM~Sunday 6PM"
                    }
                    $AddVM = Add-SPListItem -SPConnection $Using:SPOConn -ListName $SPOVMListName -ListFieldsValues $SPData
                    $UpdReq = $true
                } else {
                    if ($SPORec.VMSize -ne $VM.HardwareProfile.VmSize) {
                        $ResizeVMs += $SPORec
                    }
                }
            }
            if ($UpdReq -eq $true) {
                sleep -Seconds 30
                $SPOVMs = Get-SPListItem -SPConnection $Using:SPOConn -ListName $SPOVMListName
            }

            #$SPOVMs = Get-SPListItem -SPConnection $SPOConn -ListName $SPOVMListName
            $AllCount = $SPOVMs.count

            # Remove VM records with a DateDeleted populated
            $SPOVMs = $SPOVMs | Where-Object {$_.DateRemoved -le "1 Jan 2000"}
            $ActiveCount = $SPOVMs.count
            Write-Output "Retrieved $($AllCount) SPO records, $($AllCount - $ActiveCount) are deleted VMs"

            # Remove VM records in invalid subscriptions
            $SPOVMs = $SPOVMs | Where-Object {$_.SubscriptionGUID -in $AvailableSubs.Id}
            $ActiveCount = $SPOVMs.count
            Write-Output "Retrieved $($AllCount) SPO records, $($AllCount - $ActiveCount) are in invalid subscriptions"
            
            $Trigger = "Scheduled"
        } 
        # Otherwise just get the record requested
        else {
            Write-Output "Getting Item ID: $($Using:InParam_SPOId)"
            $SPOVMs = @()
            $SPOVMs = Get-SPListItem -SPConnection $Using:SPOConn -ListName $SPOVMListName -ListItemId $Using:InParam_SPOId
            $AllCount = $SPOVMs.count
            $Trigger = "WebHook"

            # Check for valid subscription access
            if ($SPOVMs.SubscriptionGUID -notin $AvailableSubs.Id) { # -or ($SPOVMs.SubscriptionGUID -eq $AvailableSubs.SubscriptionId))) {
                $TZ = GetTZ -TZ_string $($SPOVMs.TimeZone)
                $SPLogData.VMName_s = $($SPOVMs.Title)
                $SPLogData.SubscriptionGUID_g = $($SPOVMs.SubscriptionGUID)
                $SPLogData.ResourceGroup_s = $($SPOVMs.ResourceGroup)
                $SPLogData.TargetState_s = "Unknown"
                $SPLogData.CurrentState = "Unknown"
                $SPLogData.ItemID_d = $($SPOVMs.Id)
                $SPLogData.LocalTime_t = $(get-date ([System.TimeZoneInfo]::ConvertTimeFromUtc(((Get-Date).ToUniversalTime()), $TZ)) -Format o)
                $SPLogData.Action_s = "Error: Access Denied"
                $SPLogData.Trigger_s = $Trigger
                AddToLog -SPLogData $SPLogData
                $SPOVMs = $null
                Write-Error "Access to required Subscription denied"
                #throw "Access to required Subscription denied"
            } else {
                # Write-output "Sub OK"
                $VM = Get-AzureRmVM -Name $($SPOVMs.Title) -ResourceGroupName $($SPOVMs.ResourceGroup)
                if ($VM.HardwareProfile.VmSize -ne $SPOVMs.VMSize) {
                    $ResizeVMs += $SPOVMs
                }
            }
        }
        
        # Prepare targetVMState array
        $targetVMState = @()
        #ForEach ($TZ in ([System.TimeZoneInfo]::GetSystemTimeZones())) { Write-Output "$($TZ.DisplayName) [$($TZ.Id)]"}
        # Loop through each SharePoint record
        ForEach ($SPOVM in $SPOVMs) {
            
            #Get the TimeZone from the Sharepoint entry provided
            $TZ = GetTZ -TZ_string $($SPOVM.TimeZone)
            
            $CurrentTZDateTime = get-date ([System.TimeZoneInfo]::ConvertTimeFromUtc(((Get-Date).ToUniversalTime()), $TZ)) -Format "dd.MM.yyyy HH:mm"

            #Uncomment for debugging if required -->
            <#
                Write-Output "$($SPOVM.Title) - $($TZ.Id)"
                Write-Output "`tOverRide-Start: $($SPOVM.OverRide_x002d_Start)"
                Write-Output "`tOverRide-Stop: $($SPOVM.OverRide_x002d_Stop)"
                Write-Output "`tShutDownTimes: $($SPOVM.ShutdownTimeRange)"
                Write-Output "`tNotifications: $($SPOVM.NotificationEmail)"
            #>
            
            # Set OverRide flag to false and then starts record checks
            $OverRide = $false

            # If OverRide-Stop True then add to Target list to Stop and update OverRide flag
            # OverRide-Stop takes precedence over OverRide-Start if both are selected
            if ($SPOVM.OverRide_x002d_Stop -eq -1) {
                $target = @{
                    VMName = $($SPOVM.Title)
                    SubscriptionGUID = $($SPOVM.SubscriptionGUID)
                    ResourceGroup = $($SPOVM.ResourceGroup)
                    TargetState = "VM deallocated"
                    CurrentState = ""
                    SPOID = $($SPOVM.Id)
                    CurrentTime = $CurrentTZDateTime
                    ChildJob = $null
                    Status = "Pending"
                }
                $targetVMState += $target
                $OverRide = $true
            }

            # If OverRide-Start True and OverRide-Stop False then add to Target list to Start and update OverRide flag
            if (($SPOVM.OverRide_x002d_Start -eq -1) -and ($SPOVM.OverRide_x002d_Stop -ne -1)) {
                $target = @{
                    VMName = $($SPOVM.Title)
                    SubscriptionGUID = $($SPOVM.SubscriptionGUID)
                    ResourceGroup = $($SPOVM.ResourceGroup)
                    TargetState = "VM running"
                    CurrentState = ""
                    SPOID = $($SPOVM.Id)
                    CurrentTime = $CurrentTZDateTime
                    ChildJob = $null
                    Status = "Pending"
                }
                $targetVMState += $target
                $OverRide = $true
            }

            
            # If there is a shutdown timerange and OverRide flag is False
            if (($SPOVM.ShutdownTimeRange -ne $null) -and ($OverRide -eq $false)) {
                # Split the TimeRange and trim
                $timeRangeList = $SPOVM.ShutdownTimeRange -split "," | foreach {$_.Trim()}
                $ShutDownSched = $false

                #Loop through the list of TimeRanges found
                foreach ($timeRange in $timeRangeList) {
                    
                    #Call function CheckShutdownSchedule to see if current time specified falls inside specified range
                    $SchedCheck = CheckShutdownSchedule -InParamTimeZone $TZ.Id -InParamTimeRange $timeRange
                    #Write-Verbose "Time Checked: $($timeRange) - $($SchedCheck)"

                    #If function returns True, flag for Shutdown
                    if ($SchedCheck) {
                        $ShutDownSched = $true
                    }
                }
                
                #Set the target State based on return schedule check
                if ($ShutDownSched) {
                    $targetState = "VM deallocated"
                } else {
                    $targetState = "VM running"
                }
                #writ
                #Add to Target list with Target State ('VM deallocated' or 'VM running')"
                $target = @{
                    VMName = $($SPOVM.Title)
                    SubscriptionGUID = $($SPOVM.SubscriptionGUID)
                    ResourceGroup = $($SPOVM.ResourceGroup)
                    TargetState = $targetState
                    CurrentState = ""
                    SPOID = $($SPOVM.Id)
                    CurrentTime = $CurrentTZDateTime
                    ChildJob = $null
                    Status = "Pending"
                }
                $targetVMState += $target
            }
            
            Write-Verbose "Time Loop Done"

            $SPLogData.VMName_s = $($SPOVM.Title)
            $SPLogData.SubscriptionGUID_g = $($SPOVM.SubscriptionGUID)
            $SPLogData.ResourceGroup_s = $($SPOVM.ResourceGroup)
            $SPLogData.TargetState_s = $target.TargetState
            $SPLogData.CurrentState = ""
            $SPLogData.ItemID_d = $($SPOVM.Id)
            $SPLogData.LocalTime_t = $(get-date ([System.TimeZoneInfo]::ConvertTimeFromUtc(((Get-Date).ToUniversalTime()), $TZ)) -Format o)
            $SPLogData.Action_s = "Checking"
            $SPLogData.Trigger_s = $Trigger

            # If there are no TimeRanges specified and neither OverRide flags are set then output message
            if (($SPOVM.ShutdownTimeRange -eq $null) -and ($OverRide -eq $false)) {
                Write-Output "`tNo Shutdown information provided"
            }
        }
        
        #Get a list of all subscriptions referenced in the TargetVMState list
        $Subs = $targetVMState.SubscriptionGUID | Select-Object -Unique
        
        #Filter out any Subscriptions the current account doesn't have access to
        $Subs = $Subs | Where-Object {$_ -in $AvailableSubs.Id}
        
        #Set PrevSub variable used to detect a change in Subscription
        $PrevSub = ""

        # Loop until all VMs in the TargetVMState list are in the desired state
        do {
            #Set StateCheck to True, this is updated to False when a VM is found in a non-targeted state
            $StateCheck = $true
            Write-Verbose "Start Do Loop"

            # Loop through the Subscriptions in the TargetVMState List
            foreach ($Sub in $Subs) {
                Write-Verbose "Start Sub Loop"
                # If the required Subscription is not selected, select it and update PrevSub variable
                if ($Sub -ne $PrevSub) {
                    Write-Verbose "Sub changed"
                    Select-AzureRmSubscription -SubscriptionId $Sub 
                    $PrevSub = $Sub
                }

                # Get a list of VMs within the targeted subscription
                # $SubTargets = $targetVMState | Where-Object {$_.SubscriptionGuid -eq $Sub}

                #Loop through each VM
                foreach ($target in $targetVMState) {
                    if ($target.SubscriptionGuid -eq $Sub) {
                        #Write-Output "VMName : $($target.VMName)"
                        #Write-Output "`tStatus : $($target.Status)"
                        
                        $SPLogData.VMName_s = $($target.VMName)
                        $SPLogData.SubscriptionGUID_g = $($target.SubscriptionGuid)
                        $SPLogData.ResourceGroup_s = $($Target.ResourceGroup)
                        $SPLogData.TargetState_s = $target.TargetState
                        $SPLogData.CurrentState = $target.CurrentState
                        $SPLogData.ItemID_d = $($target.SPOID)
                        $SPLogData.LocalTime_t = $(get-date ([System.TimeZoneInfo]::ConvertTimeFromUtc(((Get-Date).ToUniversalTime()), $TZ)) -Format o)
                        $SPLogData.Action_s = ""
                        $SPLogData.Trigger_s = $Trigger

                        # Activating, Queued, Resuming, Running, Starting, Suspending, Stopping
                        # Completed, Failed, Stopped, 
                        # Suspended
                    
                        if ($target.Status -eq "Processing") {
                            $ChildStatus = $null
                            $ChildStatus = Get-AzureRmAutomationJob -Id $target.ChildJob -ResourceGroupName $Using:ResourceGroupName -AutomationAccountName $Using:AutomationAccountName -ErrorAction SilentlyContinue
                            
                            if ($ChildStatus -ne $null) {
                                Write-Output "$($target.VMName) - Child Runbook Status: $($ChildStatus.Status)"
                            }

                            switch ($Childstatus.Status) {
                                {$_ -in ("New", "Activating", "Queued", "Resuming", "Running", "Starting", "Suspending", "Stopping")} {
                                    #Stuff is still working, Set StateCheck to False and skip checking the VM 
                                    $SkipVM = $true
                                    $StateCheck = $false
                                    $target.Status = "Processing"
                                    Write-Verbose "Stuff is still working, Set StateCheck to False and skip checking the VM"
                                }
                                {$_ -in ("Completed")} {
                                    #Jobs done, Check the VM
                                    $target.ChildJob = $null
                                    Write-Verbose "Job done, Check the VM"
                                    $target.Status = "Pending"
                                    $SPLogData.Action_s = "Job Completed"
                                    AddToLog -SPLogData $SPLogData
                                }
                                {$_ -in ("Stopped") } {
                                    #Jobs done, Check the VM
                                    $target.ChildJob = $null
                                    Write-Verbose "Job stopped, Check the VM"
                                    $target.Status = "Pending"
                                    $SPLogData.Action_s = "Job Stopped"
                                    AddToLog -SPLogData $SPLogData
                                }
                                {$_ -in ("Suspended")} {
                                    #Something went wrong, force stop the child job and throw error
                                    Write-Verbose "Something went wrong, force stop the child job and check the VM again"
                                    Stop-AzureRmAutomationJob -Id $target.ChildJob -ResourceGroupName $Using:ResourceGroupName -AutomationAccountName $Using:AutomationAccountName 
                                    #Stop-AzureRmAutomationJob -Id $target.ChildJob -ResourceGroupName $ResourceGroupName -AutomationAccountName $AutomationAccountName -Verbose
                                    $SPLogData.Action_s = "Job Suspended"
                                    AddToLog -SPLogData $SPLogData
                                    throw "Catastrophic error calling child runbook 'StartSopVM'`nStop now to avoid looping and excessive charges"
                                }
                                {$_ -in ("Failed")} {
                                    
                                    $SPLogData.Action_s = "Job Failed"
                                    AddToLog -SPLogData $SPLogData
                                    throw "Catastrophic error calling child runbook 'StartSopVM'`nStop now to avoid looping and excessive charges"
                                }
                            }
                        }
                        $VM = $null
                        $VM = Get-AzureRmVM -Name $target.VMName -ResourceGroupName $target.ResourceGroup -Status -WarningAction SilentlyContinue -ErrorAction SilentlyContinue
                        
                        if ($VM -eq $null) {
                            Write-Verbose "Getting ItemID: $($target.SPOID)"
                            $SPVMDel = Get-SPListItem -SPConnection $Using:SPOConn -ListName $SPOVMListName -ListItemId $($target.SPOID)
                            $SPDelData = @{
                                Title = $SPVMDel.Title
                                SubscriptionGUID = $SPVMDel.SubscriptionGUID
                                DateRemoved = Get-Date -Format 'dd MMM yyyy HH:mm'
                            }
                            Write-Output "Deleted $($SPVMDel.Title)"
                            $SPOUpd = Update-SPListItem -SPConnection $Using:SPOConn -ListName $SPOVMListName -ListItemId $($target.SPOID) -ListFieldsValues $SPDelData
                            if ($SPOUpd) {
                                Write-Output "Successfully marked $($SPVMDel.Title) as deleted"
                            } else {
                                Write-Output "Failed to update Sharepoint for $($SPVMDel.Title)"
                            }
                        } else {
                        
                            if ($VM.Statuses[1].DisplayStatus -eq $null) {
                                $SPLogData.CurrentState = $VM.Statuses[0].DisplayStatus
                                $target.CurrentState = $VM.Statuses[0].DisplayStatus
                            } else {
                                $SPLogData.CurrentState = $VM.Statuses[1].DisplayStatus
                                $target.CurrentState = $VM.Statuses[1].DisplayStatus
                            }

                            if ($target.Status -eq "Pending") {
                        
                                #Set required action
                                if ($target.CurrentState -eq $target.TargetState) {
                                    $ReqAct = $TargetGood
                                    $target.Status = "Completed"
                                } else {
                                    $ReqAct = $EmtpyAction
                                
                                    if (($target.CurrentState -eq "VM stopped") -and ($target.TargetState -eq "VM deallocated")) {
                                        $ReqAct = ($ReqAct -bor $StopVM)
                                    }
                                    if (($target.CurrentState -eq "VM stopped") -and ($target.TargetState -eq "VM running")) {
                                        $ReqAct = ($ReqAct -bor $StartVM)
                                    }
                                    if (($target.CurrentState -eq "VM running") -and ($target.TargetState -eq "VM deallocated")) {
                                        $ReqAct = ($ReqAct -bor $StopVM)
                                    }
                                    if ($($target.CurrentState) -like "*failed*") {
                                        $ReqAct = ($ReqAct -bor $StopVM)
                                    }
                                    if (($target.CurrentState -eq "VM deallocated") -and ($target.TargetState -eq "VM running")) {
                                        $ReqAct = ($ReqAct -bor $StartVM)
                                    }
                                    if ($Using:InParam_SPOId -eq -1) {
                                        $ReqAct = ($ReqAct -bor $MultiVMs)
                                    }
                                
                                    if ($($target.CurrentState) -eq $null) {
                                        $CurrStatus = "Updating"
                                    } else {
                                        $CurrStatus = $($target.CurrentState)
                                    }
                                }
                                #If the VM is currently deallocated and needs to be resized, do it now.
                                if ($target.CurrentState -eq "VM deallocated" -and $target.SPOID -in $ResizeVMs.Id) {
                                    $ResizeData = $ResizeVMs | where-object {$_.Id -eq $target.SPOID}
                                    Write-Output "The VM is currently deallocated and has a pending resize action, doing it now!"
                                    Write-Output "Resizing VM $($target.VMName) to $($ResizeData.VMSize)"
                                    $ResVM = Get-AzureRmVM -Name $target.VMName -ResourceGroupName $target.ResourceGroup
                                    $ResVM.HardwareProfile.VmSize = $ResizeData.VMSize
                                    Update-AzureRmVM -VM $ResVM -ResourceGroupName $target.ResourceGroup -ErrorAction Continue
                                }
                                $params = @{
                                    "InParam_SubscriptionID"=$Sub;
                                    "InParam_VMName"=$($target.VMName);
                                    "InParam_ResourceGroup"=$($target.ResourceGroup);
                                    "InParam_Action"="To Be Set"
                                }
                                Write-Verbose "ReqAct : $($ReqAct)"
                                switch ($ReqAct) {
                            
                                    {($_ -band $TargetGood) -eq $TargetGood} {
                                        Write-Output "$($target.VMName) - $($target.TargetState) : Machine all good nothing to do"
                                        $SPLogData.Action_s = "VM OK"
                                        AddToLog -SPLogData $SPLogData
                                        break
                                    }
                                    {(($_ -band $StartVM) -eq $StartVM)} {
                                        #Write-Output "Starting VM"
                                        $Params.InParam_Action = "Start"
                                    }
                                    {(($_ -band $StopVM) -eq $StopVM)} {
                                        #Write-Output "Stopping VM"
                                        $Params.InParam_Action = "Stop"
                                    }
                                    {!(($_ -band $StartVM) -eq $StartVM) -and !(($_ -band $StopVM) -eq $StopVM)} {
                                        #Required action undetermined, don't do anything
                                        Write-Output "$($target.VMName) - $($CurrStatus) : State changing, check again next loop"
                                        break
                                    }
                                    {(($_ -band $MultiVMs) -eq $MultiVMs)} {
                                        Write-Output "VM:$($target.VMName) `tCurrent: $($CurrStatus) `tTarget:$($target.TargetState) - $($Params.InParam_Action) (Child Job)"
                                        $ChildJob = Start-AzureRmAutomationRunbook -AutomationAccountName $Using:AutomationAccountName -ResourceGroupName $Using:ResourceGroupName -Name "StartStopVM" -Parameters $params
                                        $target.Status = "Processing"
                                        $target.ChildJob = $ChildJob.JobId
                                        $SPLogData.Action_s = "$($Params.InParam_Action) VM via child Runbook"
                                        AddToLog -SPLogData $SPLogData
                                        break
                                    }
                                    {!(($_ -band $MultiVMs) -eq $MultiVMs)} {
                                        Write-Output "VM:$($target.VMName) `tCurrent: $($CurrStatus) `tTarget:$($target.TargetState) - $($Params.InParam_Action) (Direct)" 
                                        if ($Params.InParam_Action -eq "Stop") {
                                            Stop-AzureRmVM -Name $target.VMName -ResourceGroupName $target.ResourceGroup -Force
                                            $SPLogData.Action_s = "Stopped VM direct"
                                            AddToLog -SPLogData $SPLogData
                                        } 
                                        if ($Params.InParam_Action -eq "Start") {
                                            Start-AzureRmVM -Name $target.VMName -ResourceGroupName $target.ResourceGroup 
                                            $SPLogData.Action_s = "Started VM direct"
                                            $SPOLogs = AddToLog -SPLogData $SPLogData
                                        }
                                        $target.Status = "Completing"
                                        break
                                    }
                                }
                            }
                        
                            $VM = Get-AzureRmVM -Name $target.VMName -ResourceGroupName $target.ResourceGroup -Status -WarningAction SilentlyContinue
                            $SPLogData.CurrentState = $VM.Statuses[1].DisplayStatus
                            $target.CurrentState = $VM.Statuses[1].DisplayStatus
                            if ($VM.Statuses[1].DisplayStatus -ne $target.TargetState) {
                                $StateCheck = $false
                                #Leave Target Status unchanged
                            }
                        }
                    }
                    
                }
                # End - ForEach ($target in $targetVMState)
            }
            if ($StateCheck -eq $false) {
                write-output "Still processing"
                sleep -Seconds 60
            }
        } until ($StateCheck -eq $true)
        Write-Output "Completed"
    }

}
